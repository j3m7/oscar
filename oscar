#!/bin/env python

import time
import sys
import argparse
import atexit
import yaml
import pathlib
import os

import systemd.daemon

SMC_PATH = pathlib.Path("/sys/devices/platform/applesmc.768")
IS_DEBUG = False

class InvalidConfiguration(Exception):
    pass

def debug(msg: str) -> None:
    if IS_DEBUG:
        print("DEBUG:", msg, file=sys.stderr)

def info(msg: str) -> None:
    print("INFO:", msg)


def warn(msg: str):
    print("WARN:", msg, file=sys.stderr)


def error(msg: str):
    print("ERROR:", msg, file=sys.stderr)
    sys.exit(1)

class Range:
    def __init__(self, name, idle, high, critical):
        self.name = name
        self.idle = idle
        self.high = high
        self.critical = critical
        self.t_high_coeff = 1.2

    @classmethod
    def fromConfigSection(cls, config, name: str, section: dict):
        range_obj = Range(name, section['idle'], section['high'], section['critical'])
        config.ranges[name] = range_obj
        return range_obj

    def __repr__(self):
        return f"<Range {self.name}: ({self.idle}, {self.high}, {self.critical})>"

    def score(self, temp: float):
        if temp < self.idle: return 0.0
        if temp > self.critical:
            return 1.0
        else:
            heat_load = (temp - self.idle) / (self.critical - self.idle)
            if heat_load > self.high:
                heat_load = heat_load * self.t_high_coeff
        return heat_load


class Location:
    def __init__(self, name: str, range: Range, description: str):
        self.name = name
        self.range = range
        self.description = description
        self.sensors = []

    @classmethod
    def fromConfigSection(cls, config, name: str, section: dict):
        description = section.pop('description', "No description")
        temp_range = config.ranges.get(section.pop('range', "default"))

        if temp_range is None:
            raise InvalidConfiguration(f"Invalid range defined on location {name}")

        location = Location(name, temp_range, description)

        for sensor_name, sensor_section in section.items():
            if not isinstance(sensor_section, dict):
                raise InvalidConfiguration(f"Found invalid section {sensor_name} in location {name}")

            Sensor.fromConfigSection(config, location, sensor_name, sensor_section)

        return location


class Sensor:
    def __repr__(self):
        return f"<Sensor: {self.name}>"

    def __init__(self, label: str, name: str, location: Location, range: Range):
        self.name = name
        self.label = label
        self.range = range
        self.location = location
        self.last_val = None
        self.path = None

        self.avg_total = 0.0
        self.avg_poll_count = 0.0

        self.high_mark = sys.maxsize * -1
        self.low_mark = sys.maxsize

        self.fans = []  # List of fans using this sensor.

    def poll(self) -> float:
        cur_temp = getSensorTemp(self.path)
        self.avg_total += cur_temp
        self.avg_poll_count += 1

        if cur_temp < self.low_mark: self.low_mark = cur_temp
        if cur_temp > self.high_mark: self.high_mark = cur_temp

        self.last_val = cur_temp
        return self.last_val

    def print_stats(self):
        stats_str = f"{self.last_val} {self.name} ({self.location.name})  avg: {round(self.avg_total / self.avg_poll_count, 2)}, max: {round(self.high_mark, 2)}, min: {round(self.low_mark, 2)}"
        return stats_str

    def score(self) -> float:
        return self.range.score(self.last_val)

    @classmethod
    def fromConfigSection(cls, config, location, name: str, section: dict):
        temp_range_name = section.get('range', location.range.name)
        temp_range = config.ranges.get(temp_range_name)

        if temp_range is None:
            raise InvalidConfiguration(
                f"Sensor {name} in location {location.name} references undefined range {temp_range_name}")

        sensor_obj = Sensor(name, section.get('name', name), location, temp_range)
        config.sensors[name] = sensor_obj
        return sensor_obj


class Fan:
    def __init__(self, name, ambientSensors, internalSensors, hysteresis):

        self.hysteresis = hysteresis
        self.ambientSensors = ambientSensors
        self.internalSensors = internalSensors

        self.fan_index = None

        self.label = ""
        self.speed = 0
        self.speed_min = 0
        self.speed_max = 0

        self.resync_counter = 0

    def _readFile(self, suffix: str):
        with open(SMC_PATH / f"fan{self.fan_index}_{suffix}") as fp:
            return fp.read()

    def readInitial(self):
        self.label = self._readFile("label").strip()
        self.speed_min = int(self._readFile("min"))
        self.speed_max = int(self._readFile("max"))

    def __repr__(self):
        return f"<Fan:{self.label}>"

    def restoreManual(self):
        self.setManual(False)

    def setManual(self, state: bool, register_callback=True):
        with open(SMC_PATH / f"fan{self.fan_index}_manual", "w") as fp:
            print(int(state), file=fp)

        # Latch the callback
        if register_callback:
            if state:
                debug(f"Registered {self.label} fan control restore callback")
                atexit.register(self.setManual, (False), {register_callback: False})
            else:
                atexit.unregister(self.setManual)

    def getCurrentSpeed(self):
        self.speed = int(self._readFile("input"))
        return self.speed

    def getThrottle(self):
        return max((self.speed - self.speed_min) / (self.speed_max - self.speed_min), 0)

    def setThrotle(self, throttle: float):
        self.setSpeed(int(throttle * (self.speed_max - self.speed_min) + self.speed_min))

    def setSpeed(self, rpm: int):

        # Update the speed every 20 speed adjustments
        self.resync_counter += 1

        if self.resync_counter > 10:
            self.getCurrentSpeed()
            self.resync_counter = 0

        rpm = min(self.speed_max, max(self.speed_min, rpm))
        with open(f"/sys/devices/platform/applesmc.768/fan{self.fan_index}_output", "w") as fp:
            print(rpm, file=fp)

        self.speed = rpm

    @classmethod
    def fromConfigSection(cls, config, name: str, section: dict):
        ambient_sensors = []

        for sensor_name in section.get('ambient'):
            sensor = config.sensors.get(sensor_name)
            if sensor is None:
                error(f"Invalid sensor referenced in internal list for fan {name}")

            ambient_sensors.append(sensor)

        internal_sensors = []
        for sensor_name in section.get('internal'):
            sensor = config.sensors.get(sensor_name)
            if sensor is None:
                error(f"Invalid sensor referenced in the internal list for fan {name}")

            internal_sensors.append(sensor)

        fan_obj = Fan(name, ambient_sensors, internal_sensors, section.get('hysteresis', 0.05))

        for sensor in fan_obj.internalSensors + fan_obj.ambientSensors:
            sensor.fans.append(fan_obj)

        config.fans[name] = fan_obj
        return fan_obj


class Config:
    def __init__(self):
        self.config = {}
        self.poll_time = 1
        self.ranges = {}
        self.sensors = {}
        self.fans = {}

    def parse(self, configFile):
        """\
        Parse and build objects from definitions in the given file.
        """

        payload = yaml.load(configFile, yaml.SafeLoader)
        self.config.update(payload)

        self.poll_time = payload.get('poll_time', self.poll_time)

        # Build temp ranges
        for name, config_section in self.config.get('temp-ranges').items():
            Range.fromConfigSection(self, name, config_section)

        # Build location and sensors
        for name, config_section in self.config.get('sensors').items():
            Location.fromConfigSection(self, name, config_section)

        # Build fans
        for name, section in self.config.get("fans").items():
            Fan.fromConfigSection(self, name, section)

    def configureSysfs(self):
        """\
        Read sensors data from the smc directory in SysFS and apply definitions to it.
        """
        systemd.daemon.notify("STATUS=Reading sensor and fan configuration from sysfs")

        for label_fn in SMC_PATH.glob("temp*_label"):
            with open(label_fn) as fp:
                sensor_label = fp.read().strip()

            if sensor_label not in self.sensors:
                debug(f"Ignoring undefined sensor {sensor_label}")
                continue

            sensor_obj = self.sensors[sensor_label]
            sensor_index = int(label_fn.name.lstrip("temp").rstrip("_label"))
            sensor_obj.path = SMC_PATH / f"temp{sensor_index}_input"

            sensor_obj.poll()

        for name, sensor in self.sensors.items():
            if sensor.path is None:
                warn(f"Unconfigured sensor {name}")
            if not sensor.fans:
                warn(f"Unused sensor {name}")

        for label_fn in SMC_PATH.glob("fan*_label"):
            with open(label_fn) as fp:
                fan_label = fp.read().strip()

            fan_index = int(label_fn.name.lstrip("fan").rstrip("_label"))

            if fan_label not in self.fans:
                print(f"Ignoring undefined fan {fan_label}")
                continue

            fan_obj = self.fans[fan_label]
            fan_obj.fan_index = fan_index
            fan_obj.readInitial()


def getSensorTemp(sensor_path):
    with open(sensor_path, "r") as fp:
        raw_val = float(fp.read().strip())
    return raw_val / 1000


def checkRequirements():
    if sys.platform != "linux":
        print("CRITICAL: This runs on linux only")
        sys.exit(1)

    if not SMC_PATH.exists():
        print(f"CRITICAL: Apple SMC Directory not found on {SMC_PATH}, is the applesmc module loaded?")
        sys.exit(1)


def createPidFile(path):
    if os.path.isfile(path):
        error(f"{path} already exists, exiting")

    with open(path, "w") as fp:
        atexit.register(os.unlink, path)
        fp.write(str(os.getpid()))

def main(args):
    config = Config()

    with open(args.config, "r") as fp:
        config.parse(fp)

    config.configureSysfs()

    createPidFile('/var/run/oscar.pid')

    for name, fan in config.fans.items():
        debug(f"Disabling firmware control on {name} Fan")
        fan.setManual(True)

    systemd.daemon.notify("READY=1")
    run_loop(config)

def run_loop(config):
    while True:
        # Get the data from all the sensors
        for name, sensor in config.sensors.items():
            sensor.poll()

        for name, fan in config.fans.items():
            fan.internalSensors.sort(key=lambda s: s.score(), reverse=True)
            fan.ambientSensors.sort(key=lambda s: s.score(), reverse=True)

            internalSensor: Sensor = fan.internalSensors[0]

            heat_in_system = internalSensor.score()
            heat_decay = fan.getThrottle() * (1 - heat_in_system)

            corrected_throttle = heat_in_system - heat_decay
            delta_throttle = corrected_throttle - fan.getThrottle()


            if abs(delta_throttle) > fan.hysteresis:
                fan.setThrotle(corrected_throttle)
                ambientSensors = fan.ambientSensors[0]
                debug(
                    f"Lead sensor {internalSensor.name} located on {internalSensor.location.description} ({internalSensor.label})")
                debug(f"Load sensor temp: {internalSensor.last_val} degC")

                debug(f"Throttle correction for {name} {round(delta_throttle, 3)} ({fan.getCurrentSpeed()} RPM)")

        time.sleep(config.poll_time)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Monitor temperatures and control fan on MacPro 6,1")

    parser.add_argument("-v", '--verbose', help='Display verbose output', action="store_true", default=False)
    parser.add_argument("-c", "--config", help="Config file to read", default="/etc/oscar.yaml")

    subparsers = parser.add_subparsers()

    args = parser.parse_args()

    if args.verbose: IS_DEBUG = True

    checkRequirements()

    main(args)
